"""
Debbie Observer for Interactive Mode Monitoring.
Provides non-intrusive observation of interactive sessions for debugging assistance.
"""

import asyncio
import logging
import time
from typing import Dict, List, Optional, Any, Callable, Set
from datetime import datetime, timedelta
from dataclasses import dataclass, field
from enum import Enum
import json

logger = logging.getLogger(__name__)


class AlertSeverity(Enum):
    """Alert severity levels"""
    INFO = "info"
    WARNING = "warning"
    ERROR = "error"
    CRITICAL = "critical"


class PatternType(Enum):
    """Types of patterns Debbie can detect"""
    STALL = "stall"
    RAPID_RETRY = "rapid_retry"
    ERROR_CASCADE = "error_cascade"
    TOOL_TIMEOUT = "tool_timeout"
    FRUSTRATION = "frustration"
    ABANDONMENT = "abandonment"
    PERMISSION_ISSUE = "permission_issue"
    CONNECTION_ISSUE = "connection_issue"


@dataclass
class Alert:
    """Alert generated by Debbie"""
    severity: AlertSeverity
    pattern: PatternType
    message: str
    suggestions: List[str] = field(default_factory=list)
    timestamp: datetime = field(default_factory=datetime.now)
    metadata: Dict[str, Any] = field(default_factory=dict)


@dataclass
class SessionMetrics:
    """Metrics tracked for each session"""
    session_id: str
    start_time: datetime = field(default_factory=datetime.now)
    message_count: int = 0
    error_count: int = 0
    tool_execution_count: int = 0
    agent_switches: int = 0
    last_activity: datetime = field(default_factory=datetime.now)
    response_times: List[float] = field(default_factory=list)
    error_history: List[Dict[str, Any]] = field(default_factory=list)
    message_history: List[Dict[str, Any]] = field(default_factory=list)
    tool_timeouts: int = 0
    detected_patterns: List[PatternType] = field(default_factory=list)


class PatternDetector:
    """Detects patterns in session behavior"""
    
    # Pattern detection thresholds
    PATTERNS = {
        PatternType.STALL: {
            'threshold': 30,  # seconds
            'description': 'Agent not responding'
        },
        PatternType.RAPID_RETRY: {
            'threshold': 3,  # attempts
            'window': 10,  # seconds
            'description': 'User retrying same command'
        },
        PatternType.ERROR_CASCADE: {
            'threshold': 5,  # errors
            'window': 60,  # seconds
            'description': 'Multiple errors in succession'
        },
        PatternType.TOOL_TIMEOUT: {
            'threshold': 30,  # seconds
            'description': 'Tool execution taking too long'
        },
        PatternType.FRUSTRATION: {
            'threshold': 5,  # rapid messages
            'window': 30,  # seconds
            'description': 'User showing signs of frustration'
        },
        PatternType.PERMISSION_ISSUE: {
            'keywords': ['permission', 'denied', 'access', 'forbidden'],
            'threshold': 2,  # occurrences
            'description': 'Permission-related errors'
        }
    }
    
    def detect_patterns(self, metrics: SessionMetrics) -> List[PatternType]:
        """Detect patterns in session metrics"""
        detected = []
        
        # Check for stalls
        if self._detect_stall(metrics):
            detected.append(PatternType.STALL)
        
        # Check for rapid retries
        if self._detect_rapid_retry(metrics):
            detected.append(PatternType.RAPID_RETRY)
        
        # Check for error cascades
        if self._detect_error_cascade(metrics):
            detected.append(PatternType.ERROR_CASCADE)
        
        # Check for frustration
        if self._detect_frustration(metrics):
            detected.append(PatternType.FRUSTRATION)
        
        # Check for permission issues
        if self._detect_permission_issues(metrics):
            detected.append(PatternType.PERMISSION_ISSUE)
        
        return detected
    
    def _detect_stall(self, metrics: SessionMetrics) -> bool:
        """Detect if agent is stalled"""
        if not metrics.response_times:
            return False
        
        # Check if current response is taking too long
        time_since_last = (datetime.now() - metrics.last_activity).total_seconds()
        return time_since_last > self.PATTERNS[PatternType.STALL]['threshold']
    
    def _detect_rapid_retry(self, metrics: SessionMetrics) -> bool:
        """Detect rapid retry pattern"""
        if len(metrics.message_history) < 3:
            return False
        
        window = self.PATTERNS[PatternType.RAPID_RETRY]['window']
        threshold = self.PATTERNS[PatternType.RAPID_RETRY]['threshold']
        
        # Check recent messages for similarity
        recent_messages = metrics.message_history[-5:]
        similar_count = 0
        
        for i in range(1, len(recent_messages)):
            time_diff = (recent_messages[i]['timestamp'] - recent_messages[i-1]['timestamp']).total_seconds()
            if time_diff < window:
                # Simple similarity check - could be enhanced
                if self._messages_similar(recent_messages[i]['content'], recent_messages[i-1]['content']):
                    similar_count += 1
        
        return similar_count >= threshold
    
    def _detect_error_cascade(self, metrics: SessionMetrics) -> bool:
        """Detect error cascade pattern"""
        if len(metrics.error_history) < 2:
            return False
        
        window = self.PATTERNS[PatternType.ERROR_CASCADE]['window']
        threshold = self.PATTERNS[PatternType.ERROR_CASCADE]['threshold']
        
        # Count recent errors
        recent_errors = [
            e for e in metrics.error_history
            if (datetime.now() - e['timestamp']).total_seconds() < window
        ]
        
        return len(recent_errors) >= threshold
    
    def _detect_frustration(self, metrics: SessionMetrics) -> bool:
        """Detect user frustration pattern"""
        if len(metrics.message_history) < 3:
            return False
        
        window = self.PATTERNS[PatternType.FRUSTRATION]['window']
        threshold = self.PATTERNS[PatternType.FRUSTRATION]['threshold']
        
        # Count rapid messages
        recent_messages = [
            m for m in metrics.message_history[-10:]
            if (datetime.now() - m['timestamp']).total_seconds() < window
        ]
        
        return len(recent_messages) >= threshold
    
    def _detect_permission_issues(self, metrics: SessionMetrics) -> bool:
        """Detect permission-related issues"""
        keywords = self.PATTERNS[PatternType.PERMISSION_ISSUE]['keywords']
        threshold = self.PATTERNS[PatternType.PERMISSION_ISSUE]['threshold']
        
        # Check error messages for permission keywords
        permission_errors = 0
        for error in metrics.error_history[-5:]:
            error_text = str(error.get('error', '')).lower()
            if any(keyword in error_text for keyword in keywords):
                permission_errors += 1
        
        return permission_errors >= threshold
    
    def _messages_similar(self, msg1: str, msg2: str) -> bool:
        """Simple message similarity check"""
        # Normalize messages
        msg1 = msg1.lower().strip()
        msg2 = msg2.lower().strip()
        
        # Exact match
        if msg1 == msg2:
            return True
        
        # Check if one is contained in the other (with some tolerance)
        if len(msg1) > 10 and len(msg2) > 10:
            if msg1 in msg2 or msg2 in msg1:
                return True
        
        # Could add more sophisticated similarity checks here
        return False


class InteractiveMonitor:
    """Monitors a single interactive session"""
    
    def __init__(self, session_id: str):
        self.session_id = session_id
        self.metrics = SessionMetrics(session_id=session_id)
        self.pattern_detector = PatternDetector()
        self.alerts: List[Alert] = []
        self._active_tool_start: Optional[datetime] = None
        self._active_tool_name: Optional[str] = None
        self._message_start: Optional[datetime] = None
    
    def on_message_start(self, message: str) -> None:
        """Called when a message processing starts"""
        self._message_start = datetime.now()
        self.metrics.last_activity = datetime.now()
        self.metrics.message_count += 1
        
        # Record message in history
        self.metrics.message_history.append({
            'timestamp': datetime.now(),
            'content': message,
            'type': 'user'
        })
        
        # Keep history bounded
        if len(self.metrics.message_history) > 100:
            self.metrics.message_history = self.metrics.message_history[-100:]
    
    def on_message_complete(self, response: Any) -> None:
        """Called when message processing completes"""
        if self._message_start:
            response_time = (datetime.now() - self._message_start).total_seconds()
            self.metrics.response_times.append(response_time)
            self._message_start = None
            
            # Keep bounded
            if len(self.metrics.response_times) > 100:
                self.metrics.response_times = self.metrics.response_times[-100:]
    
    def on_tool_start(self, tool_name: str) -> None:
        """Called when tool execution starts"""
        self._active_tool_start = datetime.now()
        self._active_tool_name = tool_name
        self.metrics.tool_execution_count += 1
    
    def on_tool_complete(self, tool_name: str, result: Any) -> None:
        """Called when tool execution completes"""
        if self._active_tool_start and self._active_tool_name == tool_name:
            execution_time = (datetime.now() - self._active_tool_start).total_seconds()
            
            # Check for timeout
            if execution_time > PatternDetector.PATTERNS[PatternType.TOOL_TIMEOUT]['threshold']:
                self.metrics.tool_timeouts += 1
            
            self._active_tool_start = None
            self._active_tool_name = None
    
    def on_error(self, error: Any) -> None:
        """Called when an error occurs"""
        self.metrics.error_count += 1
        self.metrics.error_history.append({
            'timestamp': datetime.now(),
            'error': str(error),
            'type': type(error).__name__
        })
        
        # Keep history bounded
        if len(self.metrics.error_history) > 50:
            self.metrics.error_history = self.metrics.error_history[-50:]
    
    def on_agent_switch(self, from_agent: str, to_agent: str) -> None:
        """Called when agent switches"""
        self.metrics.agent_switches += 1
    
    def check_patterns(self) -> List[Alert]:
        """Check for patterns and generate alerts"""
        new_alerts = []
        detected_patterns = self.pattern_detector.detect_patterns(self.metrics)
        
        for pattern in detected_patterns:
            if pattern not in self.metrics.detected_patterns:
                # New pattern detected
                alert = self._create_alert_for_pattern(pattern)
                if alert:
                    new_alerts.append(alert)
                    self.alerts.append(alert)
                self.metrics.detected_patterns.append(pattern)
        
        return new_alerts
    
    def _create_alert_for_pattern(self, pattern: PatternType) -> Optional[Alert]:
        """Create an alert for a detected pattern"""
        if pattern == PatternType.STALL:
            return Alert(
                severity=AlertSeverity.WARNING,
                pattern=pattern,
                message="Agent appears to be taking longer than usual to respond.",
                suggestions=[
                    "Check if the workspace is very large",
                    "Try a more specific query",
                    "Check system resources"
                ]
            )
        
        elif pattern == PatternType.RAPID_RETRY:
            return Alert(
                severity=AlertSeverity.INFO,
                pattern=pattern,
                message="Multiple similar requests detected.",
                suggestions=[
                    "Try rephrasing your request",
                    "Check if the agent understood correctly",
                    "Use /help to see available commands"
                ]
            )
        
        elif pattern == PatternType.ERROR_CASCADE:
            return Alert(
                severity=AlertSeverity.ERROR,
                pattern=pattern,
                message="Multiple errors detected in succession.",
                suggestions=[
                    "Check error messages for common cause",
                    "Verify workspace configuration",
                    "Try a simpler operation first"
                ]
            )
        
        elif pattern == PatternType.FRUSTRATION:
            return Alert(
                severity=AlertSeverity.INFO,
                pattern=pattern,
                message="Having trouble? Here are some tips.",
                suggestions=[
                    "Try breaking down your request into smaller steps",
                    "Use /debbie analyze to see recent activity",
                    "Check the agent's capabilities with /help"
                ]
            )
        
        elif pattern == PatternType.PERMISSION_ISSUE:
            return Alert(
                severity=AlertSeverity.WARNING,
                pattern=pattern,
                message="Permission issues detected.",
                suggestions=[
                    "Check file and directory permissions",
                    "Ensure output directory is writable",
                    "Try using a different directory"
                ]
            )
        
        return None
    
    def get_health_status(self) -> Dict[str, Any]:
        """Get current health status of the session"""
        avg_response_time = sum(self.metrics.response_times) / len(self.metrics.response_times) if self.metrics.response_times else 0
        error_rate = self.metrics.error_count / self.metrics.message_count if self.metrics.message_count > 0 else 0
        
        return {
            'session_id': self.session_id,
            'uptime': (datetime.now() - self.metrics.start_time).total_seconds(),
            'message_count': self.metrics.message_count,
            'error_rate': error_rate,
            'avg_response_time': avg_response_time,
            'recent_patterns': [p.value for p in self.metrics.detected_patterns[-5:]],
            'health_score': self._calculate_health_score()
        }
    
    def _calculate_health_score(self) -> float:
        """Calculate a health score from 0-100"""
        score = 100.0
        
        # Deduct for errors
        error_rate = self.metrics.error_count / max(self.metrics.message_count, 1)
        score -= error_rate * 50
        
        # Deduct for slow responses
        if self.metrics.response_times:
            avg_response = sum(self.metrics.response_times) / len(self.metrics.response_times)
            if avg_response > 10:
                score -= min((avg_response - 10) * 2, 20)
        
        # Deduct for patterns
        pattern_penalty = len(self.metrics.detected_patterns) * 5
        score -= min(pattern_penalty, 30)
        
        return max(0, min(100, score))


class DebbieObserver:
    """
    Main observer class for Debbie's interactive mode monitoring.
    Integrates with the session manager to provide non-intrusive observation.
    """
    
    def __init__(self):
        self.monitors: Dict[str, InteractiveMonitor] = {}
        self.alert_callbacks: List[Callable[[str, Alert], None]] = []
        self._pattern_check_interval = 5.0  # seconds
        self._pattern_check_task: Optional[asyncio.Task] = None
        self._enabled = True
    
    def enable(self) -> None:
        """Enable monitoring"""
        self._enabled = True
        if not self._pattern_check_task or self._pattern_check_task.done():
            self._pattern_check_task = asyncio.create_task(self._pattern_check_loop())
    
    def disable(self) -> None:
        """Disable monitoring"""
        self._enabled = False
        if self._pattern_check_task and not self._pattern_check_task.done():
            self._pattern_check_task.cancel()
    
    def add_alert_callback(self, callback: Callable[[str, Alert], None]) -> None:
        """Add a callback for when alerts are generated"""
        self.alert_callbacks.append(callback)
    
    def observe_session(self, session_id: str) -> InteractiveMonitor:
        """Start observing a session"""
        if session_id not in self.monitors:
            self.monitors[session_id] = InteractiveMonitor(session_id)
            logger.info(f"Started observing session {session_id}")
        return self.monitors[session_id]
    
    def stop_observing(self, session_id: str) -> None:
        """Stop observing a session"""
        if session_id in self.monitors:
            del self.monitors[session_id]
            logger.info(f"Stopped observing session {session_id}")
    
    # Hook methods to be called by session manager
    
    def on_message_start(self, session_id: str, message: str) -> None:
        """Hook: Called when message processing starts"""
        if not self._enabled:
            return
            
        monitor = self.monitors.get(session_id)
        if monitor:
            monitor.on_message_start(message)
    
    def on_message_complete(self, session_id: str, response: Any) -> None:
        """Hook: Called when message processing completes"""
        if not self._enabled:
            return
            
        monitor = self.monitors.get(session_id)
        if monitor:
            monitor.on_message_complete(response)
    
    def on_tool_start(self, session_id: str, tool_name: str) -> None:
        """Hook: Called when tool execution starts"""
        if not self._enabled:
            return
            
        monitor = self.monitors.get(session_id)
        if monitor:
            monitor.on_tool_start(tool_name)
    
    def on_tool_complete(self, session_id: str, tool_name: str, result: Any) -> None:
        """Hook: Called when tool execution completes"""
        if not self._enabled:
            return
            
        monitor = self.monitors.get(session_id)
        if monitor:
            monitor.on_tool_complete(tool_name, result)
    
    def on_error(self, session_id: str, error: Any) -> None:
        """Hook: Called when an error occurs"""
        if not self._enabled:
            return
            
        monitor = self.monitors.get(session_id)
        if monitor:
            monitor.on_error(error)
    
    def on_agent_switch(self, session_id: str, from_agent: str, to_agent: str) -> None:
        """Hook: Called when agent switches"""
        if not self._enabled:
            return
            
        monitor = self.monitors.get(session_id)
        if monitor:
            monitor.on_agent_switch(from_agent, to_agent)
    
    async def _pattern_check_loop(self) -> None:
        """Background task to check for patterns"""
        while self._enabled:
            try:
                await asyncio.sleep(self._pattern_check_interval)
                
                # Check each monitored session
                for session_id, monitor in list(self.monitors.items()):
                    try:
                        alerts = monitor.check_patterns()
                        for alert in alerts:
                            await self._handle_alert(session_id, alert)
                    except Exception as e:
                        logger.error(f"Error checking patterns for session {session_id}: {e}")
                        
            except asyncio.CancelledError:
                break
            except Exception as e:
                logger.error(f"Error in pattern check loop: {e}")
    
    async def _handle_alert(self, session_id: str, alert: Alert) -> None:
        """Handle a generated alert"""
        logger.info(f"Alert for session {session_id}: {alert.pattern.value} - {alert.message}")
        
        # Call registered callbacks
        for callback in self.alert_callbacks:
            try:
                # Support both sync and async callbacks
                if asyncio.iscoroutinefunction(callback):
                    await callback(session_id, alert)
                else:
                    callback(session_id, alert)
            except Exception as e:
                logger.error(f"Error in alert callback: {e}")
    
    def get_session_health(self, session_id: str) -> Optional[Dict[str, Any]]:
        """Get health status for a session"""
        monitor = self.monitors.get(session_id)
        return monitor.get_health_status() if monitor else None
    
    def get_all_sessions_health(self) -> Dict[str, Dict[str, Any]]:
        """Get health status for all monitored sessions"""
        return {
            session_id: monitor.get_health_status()
            for session_id, monitor in self.monitors.items()
        }


# Global observer instance
_observer_instance: Optional[DebbieObserver] = None


def get_observer() -> DebbieObserver:
    """Get the global Debbie observer instance"""
    global _observer_instance
    if _observer_instance is None:
        _observer_instance = DebbieObserver()
    return _observer_instance