"""
Debbie's enhanced logger with intelligent commentary and pattern detection.
"""

import logging
import time
from typing import Dict, Any, List, Optional, Callable
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
import re

from ..logging_custom import EnhancedLogMessage, LogLevel, LogSource, ComponentType

logger = logging.getLogger(__name__)


class PatternType(Enum):
    """Types of patterns Debbie can detect"""
    CONTINUATION_STALL = "continuation_stall"
    TOOL_LOOP = "tool_loop"
    ERROR_PATTERN = "error_pattern"
    PERFORMANCE_DEGRADATION = "performance_degradation"
    MEMORY_SPIKE = "memory_spike"
    WEBSOCKET_DELAY = "websocket_delay"
    CONFIGURATION_ISSUE = "configuration_issue"


@dataclass
class DetectedPattern:
    """A pattern detected in the logs"""
    pattern_type: PatternType
    confidence: float  # 0.0 to 1.0
    description: str
    evidence: List[Dict[str, Any]]
    timestamp: datetime = field(default_factory=datetime.now)
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            'pattern_type': self.pattern_type.value,
            'confidence': self.confidence,
            'description': self.description,
            'evidence_count': len(self.evidence),
            'timestamp': self.timestamp.isoformat()
        }


@dataclass
class Insight:
    """An insight generated by Debbie"""
    message: str
    confidence: float
    patterns: List[DetectedPattern]
    recommendations: List[str]
    severity: str  # "info", "warning", "critical"
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            'message': self.message,
            'confidence': self.confidence,
            'pattern_count': len(self.patterns),
            'recommendations': self.recommendations,
            'severity': self.severity
        }


class PatternDetector:
    """Detects patterns in log streams"""
    
    def __init__(self):
        self.pattern_history = []
        self.detection_rules = self._initialize_rules()
        
    def _initialize_rules(self) -> Dict[PatternType, Callable]:
        """Initialize pattern detection rules"""
        return {
            PatternType.CONTINUATION_STALL: self._detect_continuation_stall,
            PatternType.TOOL_LOOP: self._detect_tool_loop,
            PatternType.ERROR_PATTERN: self._detect_error_pattern,
            PatternType.PERFORMANCE_DEGRADATION: self._detect_performance_degradation,
            PatternType.MEMORY_SPIKE: self._detect_memory_spike,
            PatternType.WEBSOCKET_DELAY: self._detect_websocket_delay,
        }
    
    def analyze(self, event: Dict[str, Any], recent_events: List[Dict[str, Any]]) -> List[DetectedPattern]:
        """Analyze an event in context of recent events"""
        patterns = []
        
        for pattern_type, detection_func in self.detection_rules.items():
            try:
                result = detection_func(event, recent_events)
                if result:
                    patterns.append(result)
            except Exception as e:
                logger.debug(f"Error detecting {pattern_type}: {e}")
        
        return patterns
    
    def _detect_continuation_stall(self, event: Dict[str, Any], 
                                  recent_events: List[Dict[str, Any]]) -> Optional[DetectedPattern]:
        """Detect agent stalling after tool execution"""
        # Look for tool execution followed by no activity
        if event.get('action') == 'session_inspected':
            details = event.get('details', {})
            if details.get('stall_detected') and details.get('stall_duration', 0) > 30:
                # Check if previous event was tool execution
                tool_events = [e for e in recent_events[-10:] 
                             if e.get('component') == 'TOOL' or 'tool' in e.get('action', '')]
                
                if tool_events:
                    return DetectedPattern(
                        pattern_type=PatternType.CONTINUATION_STALL,
                        confidence=0.92,
                        description=f"Agent stalled for {details['stall_duration']:.1f}s after tool execution",
                        evidence=[event, tool_events[-1]] if tool_events else [event]
                    )
        return None
    
    def _detect_tool_loop(self, event: Dict[str, Any], 
                         recent_events: List[Dict[str, Any]]) -> Optional[DetectedPattern]:
        """Detect tools being called in a loop"""
        if 'tool' in event.get('action', ''):
            tool_name = event.get('details', {}).get('tool_name')
            if tool_name:
                # Count recent calls to same tool
                recent_same_tool = [
                    e for e in recent_events[-20:] 
                    if e.get('details', {}).get('tool_name') == tool_name
                ]
                
                if len(recent_same_tool) > 5:
                    return DetectedPattern(
                        pattern_type=PatternType.TOOL_LOOP,
                        confidence=0.85,
                        description=f"Tool '{tool_name}' called {len(recent_same_tool)} times recently",
                        evidence=recent_same_tool[-5:]
                    )
        return None
    
    def _detect_error_pattern(self, event: Dict[str, Any], 
                             recent_events: List[Dict[str, Any]]) -> Optional[DetectedPattern]:
        """Detect recurring errors"""
        if event.get('level') in ['ERROR', 'CRITICAL']:
            error_msg = event.get('event_summary', '')
            
            # Look for similar errors
            similar_errors = [
                e for e in recent_events[-50:]
                if e.get('level') in ['ERROR', 'CRITICAL'] and 
                self._similarity_score(error_msg, e.get('event_summary', '')) > 0.7
            ]
            
            if len(similar_errors) > 2:
                return DetectedPattern(
                    pattern_type=PatternType.ERROR_PATTERN,
                    confidence=0.8,
                    description=f"Recurring error: {error_msg[:100]}",
                    evidence=similar_errors[-3:]
                )
        return None
    
    def _detect_performance_degradation(self, event: Dict[str, Any], 
                                      recent_events: List[Dict[str, Any]]) -> Optional[DetectedPattern]:
        """Detect performance degradation"""
        if 'duration_ms' in event:
            duration = event['duration_ms']
            action = event.get('action', '')
            
            # Find similar actions
            similar_actions = [
                e for e in recent_events[-100:]
                if e.get('action') == action and 'duration_ms' in e
            ]
            
            if len(similar_actions) > 5:
                avg_duration = sum(e['duration_ms'] for e in similar_actions[:5]) / 5
                if duration > avg_duration * 1.5:  # 50% slower
                    return DetectedPattern(
                        pattern_type=PatternType.PERFORMANCE_DEGRADATION,
                        confidence=0.75,
                        description=f"Performance degradation: {action} now takes {duration}ms (avg: {avg_duration:.0f}ms)",
                        evidence=[event] + similar_actions[:2]
                    )
        return None
    
    def _detect_memory_spike(self, event: Dict[str, Any], 
                           recent_events: List[Dict[str, Any]]) -> Optional[DetectedPattern]:
        """Detect memory usage spikes"""
        memory_used = event.get('details', {}).get('memory_used_mb')
        if memory_used and memory_used > 400:  # High memory usage
            return DetectedPattern(
                pattern_type=PatternType.MEMORY_SPIKE,
                confidence=0.9,
                description=f"High memory usage detected: {memory_used:.1f}MB",
                evidence=[event]
            )
        return None
    
    def _detect_websocket_delay(self, event: Dict[str, Any], 
                               recent_events: List[Dict[str, Any]]) -> Optional[DetectedPattern]:
        """Detect WebSocket communication delays"""
        if 'websocket' in event.get('component', '').lower():
            response_time = event.get('details', {}).get('response_time_ms')
            if response_time and response_time > 1000:  # 1 second delay
                return DetectedPattern(
                    pattern_type=PatternType.WEBSOCKET_DELAY,
                    confidence=0.85,
                    description=f"WebSocket delay detected: {response_time}ms",
                    evidence=[event]
                )
        return None
    
    def _similarity_score(self, text1: str, text2: str) -> float:
        """Calculate similarity between two strings (0.0 to 1.0)"""
        # Simple word-based similarity
        words1 = set(text1.lower().split())
        words2 = set(text2.lower().split())
        
        if not words1 or not words2:
            return 0.0
        
        intersection = words1.intersection(words2)
        union = words1.union(words2)
        
        return len(intersection) / len(union)


class InsightGenerator:
    """Generates actionable insights from detected patterns"""
    
    def generate(self, event: Dict[str, Any], patterns: List[DetectedPattern]) -> Insight:
        """Generate insight from patterns"""
        if not patterns:
            return None
        
        # Sort by confidence
        patterns.sort(key=lambda p: p.confidence, reverse=True)
        primary_pattern = patterns[0]
        
        # Generate insight based on primary pattern
        insight_methods = {
            PatternType.CONTINUATION_STALL: self._insight_continuation_stall,
            PatternType.TOOL_LOOP: self._insight_tool_loop,
            PatternType.ERROR_PATTERN: self._insight_error_pattern,
            PatternType.PERFORMANCE_DEGRADATION: self._insight_performance_degradation,
            PatternType.MEMORY_SPIKE: self._insight_memory_spike,
            PatternType.WEBSOCKET_DELAY: self._insight_websocket_delay,
        }
        
        method = insight_methods.get(primary_pattern.pattern_type)
        if method:
            return method(primary_pattern, patterns)
        
        # Default insight
        return Insight(
            message=f"Detected pattern: {primary_pattern.description}",
            confidence=primary_pattern.confidence,
            patterns=patterns,
            recommendations=["Investigate the detected pattern"],
            severity="warning"
        )
    
    def _insight_continuation_stall(self, pattern: DetectedPattern, 
                                   all_patterns: List[DetectedPattern]) -> Insight:
        """Generate insight for continuation stalls"""
        return Insight(
            message=f"Agent is waiting for user input after tool execution. {pattern.description}",
            confidence=pattern.confidence,
            patterns=all_patterns,
            recommendations=[
                "Inject continuation prompt using message_injector",
                "Update agent configuration to auto-continue after tool use",
                "Check if the tool output requires user decision"
            ],
            severity="warning"
        )
    
    def _insight_tool_loop(self, pattern: DetectedPattern, 
                          all_patterns: List[DetectedPattern]) -> Insight:
        """Generate insight for tool loops"""
        return Insight(
            message=f"Possible infinite loop detected. {pattern.description}",
            confidence=pattern.confidence,
            patterns=all_patterns,
            recommendations=[
                "Review agent logic for loop conditions",
                "Add loop detection to the agent",
                "Consider adding a maximum iteration limit"
            ],
            severity="critical"
        )
    
    def _insight_error_pattern(self, pattern: DetectedPattern, 
                              all_patterns: List[DetectedPattern]) -> Insight:
        """Generate insight for error patterns"""
        return Insight(
            message=f"Recurring errors detected. {pattern.description}",
            confidence=pattern.confidence,
            patterns=all_patterns,
            recommendations=[
                "Fix the root cause of the error",
                "Add error handling for this specific case",
                "Check configuration or dependencies"
            ],
            severity="critical"
        )
    
    def _insight_performance_degradation(self, pattern: DetectedPattern, 
                                       all_patterns: List[DetectedPattern]) -> Insight:
        """Generate insight for performance issues"""
        return Insight(
            message=f"System performance is degrading. {pattern.description}",
            confidence=pattern.confidence,
            patterns=all_patterns,
            recommendations=[
                "Profile the slow operation",
                "Check for resource constraints",
                "Consider caching or optimization"
            ],
            severity="warning"
        )
    
    def _insight_memory_spike(self, pattern: DetectedPattern, 
                             all_patterns: List[DetectedPattern]) -> Insight:
        """Generate insight for memory spikes"""
        return Insight(
            message=f"Memory usage is high. {pattern.description}",
            confidence=pattern.confidence,
            patterns=all_patterns,
            recommendations=[
                "Check for memory leaks",
                "Reduce data retention",
                "Increase memory limits if needed"
            ],
            severity="warning"
        )
    
    def _insight_websocket_delay(self, pattern: DetectedPattern, 
                                all_patterns: List[DetectedPattern]) -> Insight:
        """Generate insight for WebSocket delays"""
        return Insight(
            message=f"Network communication is slow. {pattern.description}",
            confidence=pattern.confidence,
            patterns=all_patterns,
            recommendations=[
                "Check network connectivity",
                "Monitor server load",
                "Consider connection pooling"
            ],
            severity="warning"
        )


class DebbieCommentary:
    """Debbie's intelligent commentary system"""
    
    def __init__(self, logger: 'DebbieLogger'):
        self.logger = logger
        self.pattern_detector = PatternDetector()
        self.insight_generator = InsightGenerator()
        self.recent_events = []
        self.max_recent = 1000
        
    def observe(self, event: Dict[str, Any]):
        """Analyze event and potentially add commentary"""
        # Add to recent events
        self.recent_events.append(event)
        if len(self.recent_events) > self.max_recent:
            self.recent_events = self.recent_events[-self.max_recent:]
        
        # Detect patterns
        patterns = self.pattern_detector.analyze(event, self.recent_events)
        
        if patterns:
            # Generate insight
            insight = self.insight_generator.generate(event, patterns)
            if insight:
                self._log_commentary(insight, event)
    
    def explain_stall(self, session_id: str, duration: float):
        """Explain why a session stalled"""
        self.logger.comment(
            level=LogLevel.WARNING,
            comment=f"Session stalled for {duration}s. Agent appears to be waiting for user input after tool execution. This is a known continuation issue.",
            context={
                "session_id": session_id,
                "stall_duration": duration,
                "likely_cause": "continuation_required",
                "suggested_action": "inject_continuation_prompt"
            }
        )
    
    def explain_intervention(self, action: str, reason: str, result: str):
        """Explain why Debbie intervened"""
        self.logger.comment(
            level=LogLevel.INFO,
            comment=f"Intervention: {action}. Reason: {reason}. Result: {result}",
            context={
                "intervention_type": action,
                "reason": reason,
                "result": result
            }
        )
    
    def _log_commentary(self, insight: Insight, triggering_event: Dict[str, Any]):
        """Log Debbie's commentary"""
        level_map = {
            "info": LogLevel.INFO,
            "warning": LogLevel.WARNING,
            "critical": LogLevel.ERROR
        }
        
        self.logger.comment(
            level=level_map.get(insight.severity, LogLevel.INFO),
            comment=insight.message,
            context={
                "patterns": [p.to_dict() for p in insight.patterns],
                "confidence": insight.confidence,
                "recommendations": insight.recommendations,
                "triggering_event": triggering_event.get('event_id')
            }
        )


class DebbieLogger:
    """Enhanced logger with Debbie's commentary capabilities"""
    
    def __init__(self, name: str = "debbie"):
        self.logger = logging.getLogger(name)
        self.commentary = DebbieCommentary(self)
        
    def log(self, level: LogLevel, source: LogSource, action: str, 
            message: str, **kwargs):
        """Log with enhanced context"""
        log_msg = EnhancedLogMessage(
            level=level,
            component=ComponentType.MONITOR,
            source=source,
            action=action,
            event_summary=message,
            **kwargs
        )
        
        # Log the message
        level_int = getattr(logging, level.value)
        self.logger.log(level_int, message, extra=log_msg.to_dict())
        
        # Observe for patterns
        self.commentary.observe(log_msg.to_dict())
    
    def comment(self, level: LogLevel, comment: str, context: Dict[str, Any] = None):
        """Add Debbie's commentary"""
        self.log(
            level=level,
            source=LogSource.DEBBIE_COMMENT,
            action="commentary",
            message=comment,
            details=context or {}
        )
    
    def debug(self, message: str, **kwargs):
        """Debug level logging"""
        self.log(LogLevel.DEBUG, LogSource.DEBBIE, "debug", message, **kwargs)
    
    def info(self, message: str, **kwargs):
        """Info level logging"""
        self.log(LogLevel.INFO, LogSource.DEBBIE, "info", message, **kwargs)
    
    def warning(self, message: str, **kwargs):
        """Warning level logging"""
        self.log(LogLevel.WARNING, LogSource.DEBBIE, "warning", message, **kwargs)
    
    def error(self, message: str, **kwargs):
        """Error level logging"""
        self.log(LogLevel.ERROR, LogSource.DEBBIE, "error", message, **kwargs)
    
    def critical(self, message: str, **kwargs):
        """Critical level logging"""
        self.log(LogLevel.CRITICAL, LogSource.DEBBIE, "critical", message, **kwargs)